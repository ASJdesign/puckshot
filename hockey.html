<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Puckshot — v0.3.3</title>
<style>
  :root{--bg:#0b1e2d;--ink:#e6f2ff;--panel:rgba(0,0,0,.45)}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  #stage{display:block;width:100vw;height:100vh;cursor:none}
  #topbar{position:fixed;left:12px;top:12px;display:flex;gap:8px;align-items:center;z-index:20}
  .btn{background:var(--panel);border:1px solid rgba(255,255,255,.15);border-radius:10px;padding:8px 12px;color:var(--ink);cursor:pointer}
  .pill{background:var(--panel);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:6px 10px;font-size:12px}
  #hud{position:fixed;right:10px;top:10px;background:var(--panel);padding:8px 10px;border-radius:10px;font-size:12px;line-height:1.4;z-index:20}
  #overlay{position:fixed;inset:0;display:grid;place-items:center;background:linear-gradient(180deg,rgba(0,0,0,.55),rgba(0,0,0,.65));z-index:30}
  #startBtn{font-size:18px;padding:12px 18px;border-radius:12px;background:#19b36b;color:#042015;border:none;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,.4)}
  #goalBanner{position:fixed;inset:0;display:none;align-items:center;justify-content:center;pointer-events:none;z-index:25}
  #goalBanner .text{font-size:64px;font-weight:800;letter-spacing:2px;color:#fff;text-shadow:0 4px 24px rgba(0,0,0,.6)}
  #penaltyBanner{position:fixed;inset:0;display:none;align-items:center;justify-content:center;pointer-events:none;z-index:26;
    font-weight:900;font-size:72px;letter-spacing:2px;color:#ffefef;text-shadow:0 6px 28px rgba(0,0,0,.65)}
</style>
</head>
<body>
  <div id="topbar">
    <button id="pauseBtn" class="btn">⏸︎ Pause</button>
    <span class="pill">Level <span id="levelNo">0</span> / 20</span>
    <span class="pill">Seed: <span id="seedText"></span></span>
  </div>

  <div id="hud">
    <div>Level Time: <span id="levelTime">0.00</span>s</div>
    <div>Total Time: <span id="totalTime">0.00</span>s</div>
    <div>Speed: <span id="spd">0.00</span> px/s • Spin: <span id="spinDbg">0.00</span> rad/s</div>
    <div id="penHUD">Penalties: 0</div>
  </div>

  <div id="overlay"><button id="startBtn">Start</button></div>
  <div id="goalBanner"><div class="text">GOAL!</div></div>
  <div id="penaltyBanner">PENALTY</div>
  <canvas id="stage"></canvas>

<script>
(() => {
  // ===== Canvas =====
  const can = document.getElementById('stage');
  const g = can.getContext('2d');
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const resize = ()=>{ can.width = Math.floor(innerWidth*dpr); can.height = Math.floor(innerHeight*dpr); g.setTransform(dpr,0,0,dpr,0,0); };
  addEventListener('resize', resize); resize();

  // ===== Seeded RNG =====
  function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=h<<13|h>>>19;}return function(){h=Math.imul(h^h>>>16,2246822507);h=Math.imul(h^h>>>13,3266489909);return (h^h>>>16)>>>0;}}
  function sfc32(a,b,c,d){return function(){a|=0;b|=0;c|=0;d|=0;var t=(a+b|0)+d|0;d=d+1|0;a=b^(b>>>9);b=c+(c<<3)|0;c=(c<<21|c>>>11);c=c+t|0;return (t>>>0)/4294967296;}}
  function rngFromSeed(seedStr){const seed = xmur3(seedStr); return sfc32(seed(),seed(),seed(),seed());}

  // ===== Config =====
  const GOAL_RULE = "full"; // full puck across the plane
  const TUNING = { hitBoost: 1.00, maxSpeed: 900 }; // easy tuning
  const P = { mu:0.012, microDrag:0.996, wallE:0.70, hitE:0.30, stickFric:0.60, spinKeep:0.94, stickR:22, puckR:14, botE:0.35, botFric:0.50, m:0.17, g:9.81 };

  const PENALTY_FREEZE = 2.0; // seconds of input freeze
  const PENALTY_CLOCK  = 5.0; // seconds added to total time

  // ===== State =====
  let penalties = 0;
  let penaltyTimer = 0;

  const MASTER_SEED = 'HOCKEY-SEASON-1';
  let levelIdx = 0;
  const MAX_LEVEL = 20;
  document.getElementById('seedText').textContent = MASTER_SEED;

  // ===== Organic rink (tube): y ∈ [top(x), bottom(x)] =====
  const rink = { w:1200, h:600 };
  const shape = { W:1200, H:600, top:(x)=>80, bot:(x)=>520 };

  function makeNoise1D(rng, oct=3, fall=0.5){
    const grad=new Map(), g=(i)=>{if(!grad.has(i)) grad.set(i, rng()*2-1); return grad.get(i);};
    const fade=t=>t*t*(3-2*t);
    return function(x){
      let amp=1,freq=1,sum=0,norm=0;
      for(let o=0;o<oct;o++){ const xf=x*freq,i0=Math.floor(xf),i1=i0+1,t=xf-i0; const v=(1-fade(t))*g(i0)+fade(t)*g(i1); sum+=v*amp; norm+=amp; amp*=fall; freq*=2; }
      return sum/(norm||1);
    };
  }
  function ySpanAtX(x){ x=Math.max(0,Math.min(shape.W,x)); return [shape.top(x), shape.bot(x)]; }

  // Top/bottom only — horizontal walls handled separately (to keep the goal mouth open)
  function keepInsideVertical(p){
    const [t,b]=ySpanAtX(Math.max(0,Math.min(shape.W,p.x)));
    const top=t+P.puckR, bot=b-P.puckR;
    if (p.y < top){ p.y=top; p.vy=Math.abs(p.vy)*P.wallE; }
    if (p.y > bot){ p.y=bot; p.vy=-Math.abs(p.vy)*P.wallE; }
  }

  // Goal (right side)
  const goal = { x: 1200-14, y: 250, w:14, h:100 };

  // Entities
  const mouse = { x:0,y:0,vx:0,vy:0,_px:0,_py:0,_t:performance.now()/1000 };
  addEventListener('mousemove', e=>{
    const r = can.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    const now = performance.now()/1000, dt = Math.max(1e-3, now - mouse._t);
    mouse.vx = (x - mouse._px)/dt; mouse.vy = (y - mouse._py)/dt;
    mouse._px = x; mouse._py = y; mouse._t = now; mouse.x = x; mouse.y = y;
  });

  const puck = { x: 300, y: 300, vx:0, vy:0, ang:0, w:0 };
  const inertia = ()=> 0.5 * P.m * P.puckR * P.puckR;

  let bots = [];
  const confetti = [];
  let prevX = null, prevY = null;

  // Timers & pause
  let running=false, paused=false;
  let totalTime=0, levelTime=0;
  let lastTS = performance.now();
  document.getElementById('pauseBtn').onclick = () => {
    paused = !paused;
    document.getElementById('pauseBtn').textContent = paused ? '▶︎ Resume' : '⏸︎ Pause';
  };
  document.getElementById('startBtn').onclick = ()=>{ document.getElementById('overlay').style.display='none'; running=true; };

  // Utils
  const len=(x,y)=>Math.hypot(x,y);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const randRange=(rng,a,b)=> a + rng()*(b-a);
  function clampSpeed(p){ const s=Math.hypot(p.vx,p.vy); if (s>TUNING.maxSpeed){ const k=TUNING.maxSpeed/s; p.vx*=k; p.vy*=k; } }

  // Hotkeys for tuning
  addEventListener('keydown',(e)=>{
    if (e.key===']'){ TUNING.hitBoost=+(TUNING.hitBoost+0.05).toFixed(2); console.log('hitBoost',TUNING.hitBoost); }
    if (e.key==='['){ TUNING.hitBoost=Math.max(0.1,+(TUNING.hitBoost-0.05).toFixed(2)); console.log('hitBoost',TUNING.hitBoost); }
    if (e.key==='='){ TUNING.maxSpeed+=50; console.log('maxSpeed',TUNING.maxSpeed); }
    if (e.key==='-'){ TUNING.maxSpeed=Math.max(200,TUNING.maxSpeed-50); console.log('maxSpeed',TUNING.maxSpeed); }
  });

  // ===== Level generator =====
  function generateLevel(i){
    const rng = rngFromSeed(MASTER_SEED+':'+i);

    // Size
    shape.W = rink.w = 1000 + Math.floor(rng()*400);
    shape.H = rink.h = 520 + Math.floor(rng()*200);

    // Organic curves (asymmetric)
    const nTop = makeNoise1D(rng, 3, 0.55);
    const nBot = makeNoise1D(rng, 4, 0.58);
    const marginTop = 40 + Math.floor(rng()*30);
    const marginBot = 40 + Math.floor(rng()*30);

    shape.top = (x) => {
      const u = x / rink.w;
      const wob = nTop(u*3.1) * 40 + nTop((1-u)*2.3 + 10) * 35;
      return Math.max(0, marginTop + wob);
    };
    shape.bot = (x) => {
      const u = x / rink.w;
      const wob = nBot(u*2.0 + 5) * 50 + nBot(u*4.2 + 1) * 30;
      const base = rink.h - marginBot - wob;
      const minChannel = 200;
      return Math.max(shape.top(x) + minChannel, Math.min(rink.h, base));
    };

    // Goal at right; ≥110% puck dia; clamp to legal span
    goal.w = 14; goal.x = shape.W - goal.w;
    const [yMin, yMax] = ySpanAtX(goal.x);
    const avail = Math.max(60, yMax - yMin - 40);
    const minGoalH = Math.ceil(1.10 * (2 * P.puckR));
    goal.h = Math.max(minGoalH, clamp(70 + Math.floor(rng()*120), 60, avail));
    const gyMin = yMin + 20, gyMax = yMax - 20 - goal.h;
    goal.y = clamp(gyMin + rng()*(gyMax-gyMin), gyMin, gyMax);

    // Defenders (right half only)
    const base = Math.floor(i/3), extra = (rng()<0.5?0:1), count = clamp(base+extra,0,8);
    bots = [];
    for (let k=0;k<count;k++){
      bots.push({ x: shape.W*0.60 + rng()*(shape.W*0.40-60), y: 40 + rng()*(shape.H-80), vx:0, vy:0, r: 18 + rng()*8, m:80+(rng()*25-10), target:null });
    }

    // Reset puck/timers
    puck.x = shape.W*0.25;
    puck.y = (shape.top(shape.W*0.25) + shape.bot(shape.W*0.25)) / 2;
    puck.vx=puck.vy=puck.w=0; puck.ang=0;
    levelTime=0; penaltyTimer=0; prevX = puck.x; prevY = puck.y;

    // Slight difficulty ramp
    P.mu = clamp(0.014 - i*0.0003, 0.007, 0.02);

    document.getElementById('levelNo').textContent = i;

    // Sanity
    const [tMin,tMax]=ySpanAtX(goal.x);
    console.assert(goal.y >= tMin-1 && (goal.y+goal.h) <= tMax+1, 'Goal aperture not inside shape span.');
  }

  // Bot AI & collisions
  function newBotTarget(rng,b){ b.target = { x: randRange(rng, shape.W*0.60, shape.W-60), y: randRange(rng, 40, shape.H-40) }; }
  function stepBot(dt, rng, b){
    const maxSpeed = 240 + rng()*40, maxAccel = 580 + rng()*60;
    if (!b.target || Math.hypot(b.target.x-b.x, b.target.y-b.y) < 30) newBotTarget(rng,b);
    const dx=b.target.x-b.x, dy=b.target.y-b.y, d=Math.hypot(dx,dy)||1;
    const dvx=(dx/d)*maxSpeed - b.vx, dvy=(dy/d)*maxSpeed - b.vy;
    const aMag=Math.hypot(dvx,dvy)||1, limit=maxAccel;
    const ax=dvx * Math.min(1, limit/aMag), ay=dvy * Math.min(1, limit/aMag);
    b.vx += ax*dt; b.vy += ay*dt; b.x += b.vx*dt; b.y += b.vy*dt;
    const minX = shape.W*0.55 + b.r; if (b.x < minX){ b.x=minX; b.vx=Math.abs(b.vx); }
    if (b.x > shape.W - b.r){ b.x=shape.W-b.r; b.vx=-Math.abs(b.vx); }
    if (b.y < b.r){ b.y=b.r; b.vy=Math.abs(b.vy); }
    if (b.y > shape.H - b.r){ b.y=shape.H-b.r; b.vy=-Math.abs(b.vy); }
  }

  function collideStick(puck, sx, sy, svx, svy, sr){
    const dx = puck.x - sx, dy = puck.y - sy, dist = Math.hypot(dx,dy), minD = P.puckR + sr; if (dist>=minD) return;
    const nx=(dist>1e-6)?dx/dist:1, ny=(dist>1e-6)?dy/dist:0, tx=-ny, ty=nx;
    const rvx=puck.vx - svx, rvy=puck.vy - svy, vN=rvx*nx + rvy*ny, vT=rvx*tx + rvy*ty; if (vN>=0) return;
    const dVn = -(1+P.hitE)*vN * TUNING.hitBoost;
    const maxT = Math.abs(dVn)*P.stickFric;
    const dVt = Math.max(-maxT, Math.min(maxT, -vT * TUNING.hitBoost));
    puck.vx += dVn*nx + dVt*tx; puck.vy += dVn*ny + dVt*ty;
    puck.w += (P.puckR * (P.m*dVt)) / inertia();
    puck.x = sx + nx*minD; puck.y = sy + ny*minD;
  }

  function collidePuckBot(puck, b){
    const dx = b.x - puck.x, dy = b.y - puck.y, dist=Math.hypot(dx,dy), minD=P.puckR + b.r; if (dist<=0||dist>=minD) return;
    const nx=dx/dist, ny=dy/dist, tx=-ny, ty=nx;
    const rvx=b.vx - puck.vx, rvy=b.vy - puck.vy; const vN=rvx*nx + rvy*ny, vT=rvx*tx + rvy*ty;
    if (vN>0){ const corr=(minD-dist)+0.01; puck.x-=nx*corr*0.5; puck.y-=ny*corr*0.5; b.x+=nx*corr*0.5; b.y+=ny*corr*0.5; return; }
    const invMass = 1/P.m + 1/b.m;
    const jn = -(1+P.botE)*vN / invMass; const jnx=jn*nx, jny=jn*ny;
    puck.vx -= jnx/P.m; puck.vy -= jny/P.m; b.vx += jnx/b.m; b.vy += jny/b.m;
    const jtIdeal = -vT / invMass; const jtCap = P.botFric * Math.abs(jn); const jt = Math.max(-jtCap, Math.min(jtCap, jtIdeal));
    const jtx=jt*tx, jty=jt*ty;
    puck.vx -= jtx/P.m; puck.vy -= jty/P.m; b.vx += jtx/b.m; b.vy += jty/b.m;
    const I=inertia(); const jtMag=Math.hypot(jtx,jty); const spinSign=(vT!==0)?Math.sign(-vT):1; puck.w += (P.puckR * jtMag * spinSign)/I;
    const corr=(minD-dist)+0.01; puck.x-=nx*corr*0.5; puck.y-=ny*corr*0.5; b.x+=nx*corr*0.5; b.y+=ny*corr*0.5;
  }

  function spawnConfetti(x,y){
    for(let i=0;i<80;i++){ const a=Math.random()*Math.PI*2, sp=150+Math.random()*250; confetti.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:0.9+Math.random()*0.6}); }
    const banner = document.getElementById('goalBanner'); banner.style.display='flex'; setTimeout(()=>{ banner.style.display='none'; }, 800);
  }
  function showPenaltyBanner(){ const el=document.getElementById('penaltyBanner'); el.style.display='flex'; setTimeout(()=>{ el.style.display='none'; }, 1200); }

  // ===== Main step =====
  function step(dt){
    if (!paused && penaltyTimer<=0){ totalTime += dt; levelTime += dt; }

    const cx=can.width/dpr*0.5, cy=can.height/dpr*0.5; const ox=cx - shape.W/2, oy=cy - shape.H/2;
    const sx=(penaltyTimer>0? shape.W*0.25 : mouse.x-ox);
    const sy=(penaltyTimer>0? (shape.top(shape.W*0.25)+shape.bot(shape.W*0.25))/2 : mouse.y-oy);

    // Glide + spin damp
    const s=len(puck.vx,puck.vy); if (s>0){ const dv=P.mu*P.g*dt; const ns=Math.max(0,s-dv); const k=(s>0)?ns/s:0; puck.vx*=k; puck.vy*=k; }
    const md=Math.pow(P.microDrag, dt*60); puck.vx*=md; puck.vy*=md; puck.w*=Math.pow(P.spinKeep, dt*60); puck.ang += puck.w*dt;

    if (penaltyTimer<=0) collideStick(puck, sx, sy, mouse.vx, mouse.vy, P.stickR);

    // Save previous center before integrating
    if (prevX === null){ prevX = puck.x; prevY = puck.y; }

    // Integrate
    puck.x += puck.vx*dt; puck.y += puck.vy*dt;

    // ===== Robust goal detection (before any horizontal wall bounce) =====
    const r = P.puckR;
    const frontX = goal.x;
    const backX  = goal.x + goal.w - r; // center past this => leading edge past back plane
    const prevEdgeX = (GOAL_RULE==="full") ? (prevX - r) : (prevX + r);
    const currEdgeX = (GOAL_RULE==="full") ? (puck.x - r) : (puck.x + r);

    let scored = false;

    // 1) Trailing-edge crossing of front plane (full puck)
    if (prevEdgeX < frontX && currEdgeX >= frontX){
      const dx = (currEdgeX - prevEdgeX) || 1e-9;
      const t = (frontX - prevEdgeX) / dx;
      const crossY = prevY + t * (puck.y - prevY);
      if (crossY >= goal.y && crossY <= goal.y + goal.h) scored = true;
    }

    // 2) Backup: center crosses back plane while within the mouth
    if (!scored){
      const centerPastBack = (puck.x >= backX);
      const centerYOK = (puck.y >= goal.y) && (puck.y <= goal.y + goal.h);
      if (centerPastBack && centerYOK) scored = true;
    }

    if (scored){ spawnConfetti(frontX + goal.w*0.5, puck.y); nextLevel(); }

    // Update prev center for next frame
    prevX = puck.x; prevY = puck.y;

    // Vertical (top/bottom) tube collisions
    keepInsideVertical(puck);

    // ===== Horizontal walls (after scoring) =====
    // Left wall
    if (puck.x < P.puckR){ puck.x=P.puckR; puck.vx=Math.abs(puck.vx)*P.wallE; }
    // Right wall with goal mouth cut-out
    const inAperture = (puck.y >= goal.y) && (puck.y <= goal.y + goal.h);
    if (puck.x > shape.W - r && !inAperture){ puck.x = shape.W - r; puck.vx = -Math.abs(puck.vx)*P.wallE; }

    // Bots
    const rng = rngFromSeed(MASTER_SEED+':'+levelIdx+':wander');
    for (const b of bots){ stepBot(dt, rng, b); for(let i=0;i<2;i++) collidePuckBot(puck,b); }

    // Penalty (stick hits defender)
    if (penaltyTimer<=0){
      for (const b of bots){
        const dx = sx - b.x, dy = sy - b.y;
        if (Math.hypot(dx,dy) < (P.stickR + b.r)){
          penalties++; penaltyTimer = PENALTY_FREEZE; totalTime += PENALTY_CLOCK; showPenaltyBanner();
          puck.x = shape.W*0.25; puck.y = (shape.top(shape.W*0.25)+shape.bot(shape.W*0.25))/2;
          puck.vx=puck.vy=puck.w=0; puck.ang=0;
          break;
        }
      }
    } else { penaltyTimer -= dt; if (penaltyTimer<0) penaltyTimer=0; }

    // Speed cap
    clampSpeed(puck);

    // Confetti update
    for (let i=confetti.length-1;i>=0;i--){ const p=confetti[i]; p.life -= dt; p.vy += 400*dt; p.x += p.vx*dt; p.y += p.vy*dt; if (p.life<=0) confetti.splice(i,1); }

    // HUD
    document.getElementById('spd').textContent = len(puck.vx,puck.vy).toFixed(2);
    document.getElementById('spinDbg').textContent = puck.w.toFixed(2);
    document.getElementById('levelTime').textContent = levelTime.toFixed(2);
    document.getElementById('totalTime').textContent = totalTime.toFixed(2);
    document.getElementById('penHUD').textContent = 'Penalties: '+penalties + (penaltyTimer>0?`  (Penalty: ${penaltyTimer.toFixed(1)}s)`:'' );
  }

  // ===== Draw =====
  function draw(){
    g.clearRect(0,0,can.width,can.height);
    const cx=can.width/dpr*0.5, cy=can.height/dpr*0.5; const ox=cx - shape.W/2, oy=cy - shape.H/2;

    g.save(); g.translate(ox,oy);
    // Rink polygon
    g.fillStyle="#cfe9ff"; g.strokeStyle="#1b3b5a"; g.lineWidth=2;
    const S=64; g.beginPath();
    for (let i=0;i<=S;i++){ const x=(i/S)*shape.W, y=shape.top(x); if(i===0) g.moveTo(x,y); else g.lineTo(x,y); }
    for (let i=S;i>=0;i--){ const x=(i/S)*shape.W, y=shape.bot(x); g.lineTo(x,y); }
    g.closePath(); g.fill(); g.stroke();

    // Center line
    g.strokeStyle="#b11"; g.beginPath(); g.moveTo(shape.W/2, shape.top(shape.W/2)); g.lineTo(shape.W/2, shape.bot(shape.W/2)); g.stroke();

    // Goal
    g.fillStyle="rgba(255,0,0,.12)"; g.fillRect(goal.x,goal.y,goal.w,goal.h);
    g.strokeStyle="#e33"; g.strokeRect(goal.x,goal.y,goal.w,goal.h);

    // Puck
    g.save(); g.translate(puck.x,puck.y); g.fillStyle="#2b2b2b"; g.beginPath(); g.arc(0,0,P.puckR,0,Math.PI*2); g.fill(); g.rotate(puck.ang); g.strokeStyle="rgba(255,255,255,.6)"; g.beginPath(); g.moveTo(0,0); g.lineTo(P.puckR,0); g.stroke(); g.restore();

    // Bots
    for (const b of bots){ g.save(); g.translate(b.x,b.y); g.fillStyle="#0b4"; g.beginPath(); g.arc(0,0,b.r,0,Math.PI*2); g.fill(); g.strokeStyle="rgba(0,0,0,.35)"; g.stroke(); g.restore(); }

    // Confetti
    for (const p of confetti){ g.fillStyle = `hsla(${(p.x+p.y)%360},90%,60%,${Math.max(0,p.life)})`; g.fillRect(p.x, p.y, 4, 4); }

    g.restore();

    // Stick (screen space; frozen during penalty at start)
    g.save();
    let showStickX = mouse.x, showStickY = mouse.y;
    if (penaltyTimer>0){
      const cx3=can.width/dpr*0.5, cy3=can.height/dpr*0.5; const ox3=cx3 - shape.W/2, oy3=cy3 - shape.H/2;
      showStickX = ox3 + shape.W*0.25; showStickY = oy3 + (shape.top(shape.W*0.25)+shape.bot(shape.W*0.25))/2;
    }
    g.translate(showStickX,showStickY); g.fillStyle="rgba(0,255,128,.20)"; g.strokeStyle="#0e0"; g.lineWidth=2; g.beginPath(); g.arc(0,0,P.stickR,0,Math.PI*2); g.fill(); g.stroke(); g.fillStyle="rgba(255,255,255,.85)"; g.beginPath(); g.arc(0,0,2,0,Math.PI*2); g.fill(); g.restore();
  }

  // ===== Flow =====
  function nextLevel(){
    if (levelIdx < MAX_LEVEL){ levelIdx++; generateLevel(levelIdx); }
    else { running=false; alert('Season complete! Total time: '+totalTime.toFixed(2)+'s'); }
  }

  // Init & loop
  generateLevel(0);
  document.getElementById('levelNo').textContent = levelIdx;

  requestAnimationFrame(function loop(ts){
    const dt = Math.min(0.033, (ts-lastTS)/1000); lastTS = ts;
    if (running && !paused) step(dt);
    draw();
    requestAnimationFrame(loop);
  });
})();
</script>
</body>
</html>
